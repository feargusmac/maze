/* 
 * File:   mazeSolve.cpp
 * Author: Feargus
 * 
 * Uses the Graph class and a Breadth First
 * Search algorithm so solve the mazes 
 * generated by mazeGen.
 */

#include "mazeSolve.h"
#include "doublyLinkedList.h"
#include <cmath>
#include <iostream>
#include <sstream>

/*mazeSolve::mazeSolve() {
    
}*/

mazeSolve::mazeSolve(std::string mazeString) {
    maze = getInput(mazeString);
    // TODO: do I need anything else here?
}

mazeSolve::~mazeSolve() {
    delete maze; maze = 0;
}

Graph *mazeSolve::getInput(std::string input) {
    if (input.length() == 0) {
        std::cout << "No input detected" << std::endl;
        exit(0);
    } // if no input
    
    // TODO: is there a better way to do this?
    dimension = 0;
    while (input[dimension] != '\n') dimension++;
    
    Graph *mazeGraph = new Graph(dimension);
    
    // add each line to graph
    for (int i = 0; i < dimension; i++) {
        std::string str = "";
        int start = i*(dimension+1);
        for (int j = start; j < start+dimension; j++) {
            if (!isHex(input[j])) {
                std::cerr << "Input " << j << " is not hex." << std::endl;
                exit(1);
            }
            str += input[j];
        }
        
        mazeGraph->mazeArray[i] = str;
    }
    
    return mazeGraph;    
}

void mazeSolve::solve() {
    BFS(0);
    printPath((dimension*dimension - 1)); // start at the end
}

void mazeSolve::BFS(int source) {
    Queue<int> queue;
    maze->color[source] = GREY;
    maze->distance[source] = 0;
    maze->parent[source] = 0;
    queue.enque(source);
    
    while(!queue.isEmpty()) {
        int t = queue.deque();
        std::vector<int> adjCells = adj(t);
        for (int v : adjCells) {
            if (maze->color[v] == WHITE) {
                maze->color[v] = GREY; // grey again enumerate this
                maze->parent[v] = t;
                maze->distance[v] = maze->distance[t]+1;
                queue.enque(v);
            }
        }
        maze->color[t] = BLACK; // black see above
    }
}

std::vector<int> mazeSolve::adj(int t) {
    std::vector<int> adjCells;
    
    int convertedInteger;
    std::stringstream ss;
    ss << std::hex << maze->mazeArray[maze->getRow(t)][maze->getColumn(t)];
    ss >> convertedInteger;
    
    // ___find all adjacent cells and convert to integers
    if ((convertedInteger | RIGHTSIDE) != convertedInteger) {
        int cell = maze->right(t);
        if (cell >= 0) 
            adjCells.push_back(cell);
    }
    
    if ((convertedInteger | BOTTOM) != convertedInteger) {
        int cell = maze->below(t);
        if (cell >= 0)
            adjCells.push_back(cell);
    }
    
    if ((convertedInteger | LEFTSIDE) != convertedInteger) {
        int cell = maze->left(t);
        if (cell >= 0)
            adjCells.push_back(cell);
    }
    
    if ((convertedInteger | TOP) != convertedInteger) {
        int cell = maze->above(t);
        if (cell >= 0) 
            adjCells.push_back(cell);
    }
    
    return adjCells;
}

void mazeSolve::printPath(int cell) {
    if (cell > 0) {
        printPath(maze->parent[cell]);
        
        std::cout << "(";
        std::cout << maze->getRow(maze->parent[cell]);
        std::cout << ", ";
        std::cout << maze->getColumn(maze->parent[cell]);
        std::cout << ")" << std::endl;
    }
}

bool mazeSolve::isHex(char c) {
    if (c == '0' 
         || c == '1'
         || c == '2'
         || c == '3'
         || c == '4'
         || c == '5'
         || c == '6'
         || c == '7'
         || c == '8'
         || c == '9'
         || c == 'a'
         || c == 'b'
         || c == 'c'
         || c == 'd'
         || c == 'e'
         || c == 'f')
        return true;
    else
        return false;
}
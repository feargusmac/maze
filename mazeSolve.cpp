/* 
 * File:   mazeSolve.cpp
 * Author: Feargus
 * 
 * Uses the Graph class and a Breadth First
 * Search algorithm so solve the mazes 
 * generated by mazeGen.
 */

#include "mazeSolve.h"
#include <iostream>
#include <queue> // make my own queue class
#include <sstream>

/*mazeSolve::mazeSolve() {
    
}*/

mazeSolve::mazeSolve(std::string mazeString) {
    // **** DEBUG ****
    std::cout << std::endl << mazeString << std::endl;
    // ****       ****
    maze = getInput(mazeString);
    
}



mazeSolve::~mazeSolve() {
    delete maze; maze = 0;
}

Graph *mazeSolve::getInput(std::string input) {
    std::getline(std::cin, input); // read just first line
    // **** DEBUG ****
    std::cout << input << std::endl;
    // ****       ****
    dimension = input.length();
    if (dimension == 0) {
        std::cout << "No input detected" << std::endl;
        exit(0);
    } // if no input
    
    Graph *mazeGraph = new Graph(dimension);
    mazeGraph->maze[0] = input; // add the first line to the maze graph
    
    // get rest of input
    int index = 1; // why are we using this and not just using i???
    for (int i = 1; i < dimension; i++) {
        getline(std::cin, input);
        if (input.empty() || input.length() != dimension) { // any further checks needed?
            std::cout << "Bad input" << std::endl;
            exit(1);
        }
        mazeGraph->maze[index] = input;
        index++;
    }
    
    return mazeGraph;    
}

void mazeSolve::solve() {
    BFS(0);
    printPath((dimension*dimension - 1)); // start at the end
}

void mazeSolve::BFS(int source) {
    std::queue<int> myQ;
    maze->color[source] = 1; // TODO: enumerate colors
    maze->distance[source] = 0;
    maze->parent[source] = 0;
    myQ.push(source);
    
    while(!myQ.empty()) {
        int t = myQ.front();
        std::vector<int> adjCells = adj(t);
        for (int v : adjCells) {
            if (maze->color[v] == 0) {
                maze->color[v] = 1; // grey again enumerate this
                maze->parent[v] = t;
                maze->distance[v] = maze->distance[t]+1;
                myQ.push(v);
            }
        }
        myQ.pop();
        maze->color[t] = 2; // black see above
    }
}

std::vector<int> mazeSolve::adj(int t) {
    std::vector<int> adjCells;
    
    int convertedInteger;
    std::stringstream ss;
    ss << std::hex << maze->maze[maze->getRow(t)][maze->getColumn(t)];
    ss >> convertedInteger;
    
    // ___find all adjacent cells and convert to integers
    // check right - 1                  // TODO: enumerate these as well
    if ((convertedInteger | 1) != convertedInteger) {
        int cell = maze->right(t);
        if (cell >= 0) 
            adjCells.push_back(cell);
    }
    
    // check bottom - 2
    if ((convertedInteger | 2) != convertedInteger) {
        int cell = maze->bottom(t);
        if (cell >= 0)
            adjCells.push_back(cell);
    }
    
    // check left - 3
    if ((convertedInteger | 4) != convertedInteger) {
        int cell = maze->left(t);
        if (cell >= 0)
            adjCells.push_back(cell);
    }
    
    // check top - 8
    if ((convertedInteger | 8) != convertedInteger) {
        int cell = maze->top(t);
        if (cell >= 0) 
            adjCells.push_back(cell);
    }
    
    return adjCells;
}

void mazeSolve::printPath(int cell) {
    if (cell > 0) {
        printPath(maze->parent[cell]);
        
        std::cout << "(";
        std::cout << maze->getColumn(maze->parent[cell]);
        std::cout << ", ";
        std::cout << maze->getRow(maze->parent[cell]);
        std::cout << ")" << std::endl;
    }
}